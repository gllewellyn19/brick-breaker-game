# Simulation Design Final
### Names
Priya Rathinavelu (plr11) Grace Llewellyn (gal16)
## Team Roles and Responsibilities
We didn't assign specific roles while completing the project, but as we worked we focused on different parts of the requirements. 
 * Team Member #1
Grace - I worked on the brick classes and the abstraction created for that. I also worked on reducing the size of the main Game class by breaking up the project and creating a new collisions class. I also worked on creating the Level abstraction and the level classes that implemented it. I formatted the files that contained our brick configurations. I created the special functions of each level that involved the paddle moving up and down and a new obstacle class. I also broke up our level class into game display and game brick display 
 * Team Member #2
Priya -  I worked on testing our different classes and making sure that our public methods for our classes were functioning how they were meant to. In addition, I worked on creating the display for the high score and made sure that the score is recorded after winning a game, and that the high score is read in from the values stored in the file. I also worked on the animation of the brick falling and making sure that it only fell if the brick was hit on its last hit and also a power up. Lastly, I worked on making sure that our bricks included different patterns instead of just colors so that they would match our nature theme. 
## Design goals
Our project's design goals were to create a nature themed breakout game. We styled the bricks and the paddle to go along with this theme. We have different images on our paddles and bricks such as tents and hiking boots. We wanted the game to look exciting and kept this in mind while doing our brick configuration files. We decided we wanted to have a lot of different power ups and cheat keys, and did more than required. We also wanted to make our methods short and readable and focus on breaking up our large classes so that one class was not doing all the work which is easy to accidentally do in this project. We also designed everything emphasizing the open closed principle, for example, how easy it would be to add a new level which is described below.
#### What Features are Easy to Add
We also wanted to make new bricks easier to add by having them implement either the abstract class BrickWithPowerUp or BrickWithSpecialAction. If the brick implements the BrickWithPowerUp class, it only needs to implement initializeBrick and updateHitToBrick. If the brick implements the BrickWithSpecialAction class, it only needs to implement initializeBrick, updateHitToBrick, and doSpecialAction. All of these methods don?t have to be implemented with code, just overwritten. This list of new bricks can be put into a list and passed into the level constructor where initialize brick is called when the level is being displayed. 
We wanted the addition of new levels to also be simple, which can be done by having new levels implement the abstract Level class. Creating a new level just requires calling the constructor of level and inputting the different parameters, such as the brick configuration text file, number of starting lives,and a list of image file names for the brick patterns and creating a new level also involves implementing the doSpecialFeature class which is called everything the game steps (no code needs to go in this method though). To make each level different, we can override any method in the level class to include a unique feature to the new level. For example, our level 1 includes a large stationary block in the middle of the screen (which it does by overriding the initialize level class to create that block and utilizes the Obstacle class created for it), whereas in level 2, this large block is moving (implemented through the doSpecialFeature which is called every step). Level 3 overrides the checkPaddleMovement method and makes it so the paddle movement can also be up and down. Within our Game class, there a list of levels that the user can play through, so any new levels would need to be included in this list so that the user has access to them. 
It was also easy to change any of the hearts display, brick configuration files, or paddle/ brick images you just have to overwrite the file they were saved in 

## High-level Design
Overall, the project had a Game class that handled everything (and for switching between levels), and a level class that handles everything for the current level such as its display. The level also maintained a ball and paddle, while the bricks were maintained in GameBrickDisplay which level had an instance of. The Brick class was also a superclass that was implemented by BrickWithPowerUp and BrickWithSpecialAction abstract classes and certain instances of special bricks implemented these. 
#### Core Classes
##### Purpose of core classes:
Game - This class focuses on the general set up of the game and the transitions between the different levels. It also handles any cheat keys that the user calls.  
Collision- This class focuses on the interactions between ball, paddle and bricks. This class makes sure that if there is a collision, or something is about to go out of bounds that it bounces off of or counts the intersection as a brick hit. 
Level - This abstract class allows for the creation of each level as well as the game display and game brick display associated with the level. This class also checks if the game has finished and if the user won/lost. 
Game Display- game display manages the display of the lives, score, level and high score. This is told when to update any of these things and applies it to the Text field or images of the heart 
Game Brick Display- this class creates the brick display from the configuration files given and maintains a list of bricks for the level class 
##### Interactions between core classes: 
Game was the main handler of all the classes that had a main and dealt with the overall game rules. Game had a list of levels (along with current level to call commands on) and a Collision class. The Collision class also had a current level that it used to access the bricks of that class so it could update hits to the brick or destroy them, change the score based on a brick hit and get access to the ball and paddle that were in the level class. 

The level class created new instances of game display and game brick display that would handle what was shown to the user for that specific level. When creating a level, the size of the game, the number of starting lives, and the location of where to display the lives needs to be indicated. These values are passed into the game display class which created the basic interface of the game. The game display also handled keeping track of the score for the user. Adding the different bricks onto the screen was managed by the game brick display class. When creating a level, we had to indicate the location of a file that contains information about how the bricks should be set up as well as a list of image names for the brick patterns. These parameters are passed into the game brick display class that create the differently patterned bricks that have unique power ups and hits to break them depending on their value from the file read in. 
## Assumptions that Affect the Design
We assumed that all the files that we needed to create the hearts, etc. were in the data folder. We assumed that a user that wanted to implement a new level would have to not only create a new class with a constructor (since we didn?t read in from a file), but also they would need to add a new level object to the list of levels in Game. We realize that this is not ideal as if we read this information in from a file, the user would not have to do any of that, but we didn?t think we were prepared to do that this early in the game. Also, making the levels functionally different is something that would need to be done with coding rather than reading in from a file. The user would also have to implement the brick class if they wanted to create any more bricks. We also assumed some constant things about the ball and paddle that the user could not specify such as the default size and speed. We assumed that the user could only play with the arrows keys rather than using their mouse. 
#### Features Affected by Assumptions
The features affected by these assumptions were the level and brick classes. These classes don?t have methods to read from files, but rather expect to have their constructor called. 
The ball size, ball speed, paddle length, paddle width and paddle default shift amount for the game were also affected by our assumptions because the user could not change the starting value of these features. These values remain constant unless they are changed due to a power up or a cheat key  (such as the power up that increases the paddle size or the cheat key that increases the speed of the ball). Had we made these features have values that could be set when creating the level, then each level could have different starting speeds and size of the objects, allowing for a more unique game play experience. 

## New Features HowTo
New level - To create a new level, we use the abstract class Level and specify the features unique to the new level in the constructor. These features include size of the screen of the game, which file to read in the brick configurations in from, which list of images will be used for the pattern of each brick, which image will be used for the paddle of the brick, and a list of bricks with power ups/ special actions that are available for that level. After instantiating a new level using that constructor, we can override any of the methods found in the Level class. For example, if we want our new level to include a new type of paddle movement, we can override the checkPaddleMovement method found in the Level class. If we want our new level to have some unique feature, like level 1 containing an obstacle in the middle of the screen, we can override the doSpecialFeature method and the initializeLevel method to include a new component. 
To actually add the new level to the Game, it must be added in the list of type Level that is a constant in the Game class. 
New brick. To create a new brick, you can either extend the normal brick class, or you can implement the BrickWithPowerUp or BrickWithSpecialAction classes and override some methods, depending on what you want to do with the brick. For example, we make an exploding brick that extends the abstract method of the BrickWithSpecialAction class doSpecialAction (this is called when the brick is out of hits) and when it is hit, it gets all the bricks from the current level and removes the bricks around it. Another example of a brick that implements BrickWithSpecialPowerUp is the increase paddle size brick that overrides the destoryBrick function that is called when the brick is hit. This method has currentLevel as a parameter, so this brick class can change the paddle size. 

#### Other Features not yet Done
A feature that was not fully implemented was the transition screens. We created an abstract method of the level class called initializeLevelScreen that would be called when the level was first called and would display the contents of the corresponding text file. We would have a boolean for the current level, isOnDisplayScreen, and when that is true and a key is pressed, then we would initialize and start the level.  We implemented simple versions of a screen in between levels that indicate if the user won/lost and what keys they should press to move onto the next round or replay that same level. We also wanted to make more levels including one that just had one moving brick (done with passing in a brick configuration with one file and move that brick in the doSpecialFeature method in Level). Below we describe the features we included in our plan but couldn't fully complete and how we would have implemented them with more time (which is most of the features we wanted to do). We also should have had an abstract key input method called to level that could be overriden so new levels can use key input. For transition screens this would have helped so initialize level would created a transition screen and initialize level would have only started when the user overwrote checking the input that indicated to move to the next level (boolean in level to see if on transition screen).
#### Major differences between plan and our project
The biggest difference was the design. Based on the samples we were given, we felt like the design needed to be really good and creative, however given our time constraints and what we currently know about javafx, that would have been very difficult. We had high expectations for our backgrounds that we didn?t meet. However, we did follow our plan about the design of the brick and paddle. We also wanted to implement Devilish (like the example), but ended up not having time. It wouldn't have been that hard since you have access to the bricks and override the doSpecialFeature method which is called every step to make it so the bricks were coming down very slowly. The brick configuration file for this would also have to be more complex. Also a method in GameBrickDisplay would have to be overridden so that all the bricks are not displayed on the screen at once. Two other features we didn?t implement were the lasers and invisible bricks. We didn?t have time to do these but have an idea for how to implement them. Lasers coming out of the paddle would be implemented in the level class with the function doSpecialAction that is called every step. This would accrue the value of elapsed time to some value and have little rectangles come from the location of the sides of the paddle. When the elapsed time accrued to the value, this function would stop for some period of time. Also, a method checking to see if the lasers hit the bricks would be in the doSpecialAction method. If the user hit an invisible brick (implemented BrickWithSpecialAction), then the doSpecialAction function would cause all the bricks to turn their opaqueness to 0 which can be done since this method has access to current level and its bricks. 

